# Research Decision Log
# SafeDownload Research → Decision Framework
# Version: 1.0.0

---
# How to Use This Document
#
# When a research area produces a decision:
# 1. Add a new entry to the `decisions` array below
# 2. Fill in all required fields
# 3. Update research_plan.yaml statistics
# 4. Update the relevant feature spec
# 5. Add to CHANGELOG.md if significant
#
# Decision Lifecycle:
#   PROPOSED → UNDER_REVIEW → APPROVED → IMPLEMENTED
#              ↓
#           REJECTED
---
metadata:
  version: "1.0.0"
  created: "2025-12-25"
  updated: "2025-12-26"
  total_decisions: 2
  decisions_pending: 2
  decisions_approved: 0
  decisions_implemented: 0

# Decision Criteria Weights
# Used when scoring options in research comparisons
criteria_weights:
  constitution_alignment: 25 # Does it align with project principles?
  performance: 20 # Does it meet performance gates?
  maintainability: 20 # Easy to maintain long-term?
  developer_experience: 15 # Good DX for contributors?
  community_support: 10 # Active community, documentation?
  dependency_footprint: 10 # Minimal dependencies per constitution?

# Decision Categories
categories:
  - name: "LIBRARY_SELECTION"
    description: "Choice of external library or framework"
    typical_criteria:
      - "License compatibility (BSD/MIT/Apache preferred)"
      - "Active maintenance (commits in last 6 months)"
      - "Documentation quality"
      - "Dependency count"
    required_fields:
      - "options_evaluated"
      - "selection_rationale"
      - "fallback_option"

  - name: "ARCHITECTURE_PATTERN"
    description: "Structural design decision"
    typical_criteria:
      - "Testability"
      - "Modularity"
      - "Performance impact"
      - "Complexity budget"
    required_fields:
      - "pattern_name"
      - "trade_offs_accepted"
      - "migration_path"

  - name: "IMPLEMENTATION_APPROACH"
    description: "How to implement a specific feature"
    typical_criteria:
      - "Effort estimate"
      - "Risk assessment"
      - "Constitution compliance"
    required_fields:
      - "approach_description"
      - "alternatives_rejected"

  - name: "PLATFORM_SUPPORT"
    description: "Platform/OS specific decisions"
    typical_criteria:
      - "Tier 1 platform compatibility"
      - "Testing feasibility"
      - "Maintenance burden"
    required_fields:
      - "platforms_affected"
      - "platform_specific_notes"

# Decision Template
# Copy this when adding a new decision
decision_template:
  id: "D000"
  title: "Decision Title"
  category: "LIBRARY_SELECTION" # One of categories above
  research_id: "R00" # Which research area produced this
  feature_ids: # Which features this affects
    - "F000"
  status: "PROPOSED" # PROPOSED | UNDER_REVIEW | APPROVED | REJECTED | IMPLEMENTED

  dates:
    proposed: null
    approved: null
    implemented: null

  context:
    problem_statement: "What problem does this solve?"
    constraints: []
    assumptions: []

  options_considered:
    - name: "Option A"
      pros: []
      cons: []
      score: null
    - name: "Option B"
      pros: []
      cons: []
      score: null

  decision:
    selection: "Option A"
    rationale: "Why this option was chosen"
    trade_offs_accepted:
      - "Trade-off 1 we accept"
    fallback_plan: "If this doesn't work, we will..."

  implementation:
    effort_estimate: "S/M/L"
    blocking_tasks: []
    non_blocking_tasks: []

  review:
    reviewers: []
    concerns_raised: []
    concerns_addressed: []

  validation:
    success_criteria: []
    validation_method: "How we'll know this was right"
    revisit_trigger: "Conditions that should trigger reconsideration"

# Actual Decisions
# Add new decisions here as research produces them
decisions:
  - id: "D001"
    title: "HTTP Client Library Selection for Go Core"
    category: "LIBRARY_SELECTION"
    research_id: "R01"
    feature_ids:
      - "F011"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-25"
      approved: null
      implemented: null

    context:
      problem_statement: "Need to select HTTP client approach for SafeDownload's Go core download engine, supporting resumable downloads via Range headers"
      constraints:
        - "Must support HTTP Range headers for resume (Constitution Principle III)"
        - "Minimal external dependencies (Constitution Principle II)"
        - "Context cancellation for clean abort"
        - "Connection pooling for concurrent downloads"
      assumptions:
        - "Performance is comparable across options with proper configuration"
        - "stdlib net/http provides sufficient primitives"
        - "Custom wrapper development effort is acceptable (2-3 days)"

    options_considered:
      - name: "stdlib net/http with custom wrapper"
        pros:
          - "Zero external dependencies"
          - "Full control over implementation"
          - "Battle-tested by millions of Go applications"
          - "Maintained by Go team"
          - "HTTP/2 automatic upgrade"
          - "First-class context cancellation"
        cons:
          - "More boilerplate code needed"
          - "Must implement progress tracking manually"
          - "Resume logic requires custom implementation"
        score: 91.5

      - name: "grab library (github.com/cavaliergopher/grab)"
        pros:
          - "Built-in resume support"
          - "Progress tracking via channels"
          - "Checksum verification included"
          - "Batch download API"
          - "Well-designed API"
        cons:
          - "Last major update 4 years ago"
          - "28 open issues"
          - "External dependency"
          - "No HTTP/2 optimizations"
        score: 71.0

      - name: "resty library (github.com/go-resty/resty)"
        pros:
          - "Actively maintained"
          - "Large community (11k+ stars)"
          - "Rich middleware ecosystem"
        cons:
          - "Not designed for file downloads"
          - "No resume support built-in"
          - "Heavy feature set we don't need"
          - "Multiple transitive dependencies"
        score: 71.5

      - name: "go-retryablehttp (github.com/hashicorp/go-retryablehttp)"
        pros:
          - "Automatic retry with backoff"
          - "Maintained by HashiCorp"
        cons:
          - "MPL-2.0 license (more restrictive)"
          - "Retries entire request, not resume"
          - "80 open issues"
          - "External dependency"
        score: 66.5

    decision:
      selection: "stdlib net/http with custom wrapper"
      rationale: |
        stdlib net/http provides all primitives needed for resumable downloads
        while maintaining zero external dependencies. This aligns perfectly with
        Constitution Principle II (minimal dependencies). The grab library
        offers excellent patterns to study and inform our wrapper design, but
        its maintenance status (4 years since major update) creates long-term risk.

        Key factors:
        1. Zero dependencies = no external project risk
        2. Full control over resume behavior implementation
        3. Can be optimized specifically for our use case
        4. Go team maintenance ensures long-term stability
      trade_offs_accepted:
        - "Additional 2-3 days development time for wrapper"
        - "Must implement and test resume logic ourselves"
        - "Progress tracking requires custom implementation"
      fallback_plan: "If custom wrapper proves problematic, can adopt grab as a reference and port specific modules"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Create download manager wrapper with Resume support"
        - "Implement connection pooling configuration"
        - "Write comprehensive tests for Range header handling"
      non_blocking_tasks:
        - "Benchmark against grab for performance validation"
        - "Document API surface for future contributors"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "Resume correctly handles 206 Partial Content responses"
        - "Graceful degradation when Range not supported"
        - "Connection pool efficiently handles concurrent downloads"
        - "Startup time <500ms (performance gate)"
        - "Memory usage within acceptable bounds"
      validation_method: "Integration tests + benchmarks during Sprint 01"
      revisit_trigger: "If implementation takes >5 days or performance benchmarks fail gates"

  - id: "D004"
    title: "Accessible Terminal UI Implementation Approach"
    category: "IMPLEMENTATION_APPROACH"
    research_id: "R04"
    feature_ids:
      - "F008"
      - "F014"
    status: "PROPOSED"

    dates:
      proposed: "2025-12-26"
      approved: null
      implemented: null

    context:
      problem_statement: "Need to implement accessible terminal UI that works with screen readers, respects color preferences, and supports colorblind users while maintaining visual appeal"
      constraints:
        - "Must respect NO_COLOR environment variable (Constitution Principle XI)"
        - "Screen readers work through terminal emulators, not apps directly"
        - "WCAG 2.1 AA compliance required (4.5:1 contrast ratio)"
        - "Cannot require specific terminal emulator"
      assumptions:
        - "Users with screen readers prefer GNOME Terminal, iTerm2, or Windows Terminal"
        - "VoiceOver and NVDA are the primary screen readers to support"
        - "Emoji + text pattern provides both visual and semantic information"

    options_considered:
      - name: "Full screen reader optimization with live regions"
        pros:
          - "Best possible screen reader experience"
          - "Real-time progress announcements"
        cons:
          - "Terminal emulators don't support ARIA live regions"
          - "Implementation complexity very high"
          - "Inconsistent across terminals"
        score: 35

      - name: "Static text output with --plain flag"
        pros:
          - "Works with all screen readers"
          - "Simple implementation"
          - "Predictable behavior"
        cons:
          - "Less visually appealing"
          - "No progress animations"
        score: 75

      - name: "Layered approach: TUI default + --plain flag + NO_COLOR"
        pros:
          - "Best experience for each user type"
          - "Constitution compliant (Principle XII)"
          - "termenv library handles detection"
          - "Graceful degradation built-in"
        cons:
          - "Must maintain two output modes"
          - "Testing complexity increased"
        score: 92

    decision:
      selection: "Layered approach with TUI default, --plain flag, and NO_COLOR support"
      rationale: |
        The layered approach provides the best experience for all users:
        1. TUI mode: Rich visuals with ANSI 16-color palette for most users
        2. --plain flag: Screen reader users get linear, predictable output
        3. NO_COLOR: Automatic detection disables all styling

        Research confirmed that screen readers interact with terminal emulators,
        not applications directly. The emoji + text pattern (✅ Success, ⚠️ Warning)
        provides semantic meaning regardless of emoji rendering support.

        The termenv library (★1600, actively maintained) provides reliable
        terminal capability detection for Go implementation.
      trade_offs_accepted:
        - "Must maintain two output code paths (TUI and plain)"
        - "Cannot provide animated progress to screen reader users"
        - "Testing requires manual verification with actual screen readers"
      fallback_plan: "If termenv proves problematic, can implement simplified detection using TERM and COLORTERM environment variables"

    implementation:
      effort_estimate: "M"
      blocking_tasks:
        - "Implement --plain flag in CLI contract"
        - "Add NO_COLOR and SAFEDOWNLOAD_PLAIN environment variable detection"
        - "Create ANSI 16-color palette with WCAG AA compliance"
        - "Implement linear output mode for screen readers"
      non_blocking_tasks:
        - "Add high-contrast theme as additional option"
        - "Document accessibility features in user guide"
        - "Create colorblind simulation testing workflow"

    review:
      reviewers: []
      concerns_raised: []
      concerns_addressed: []

    validation:
      success_criteria:
        - "--plain flag produces fully linear output"
        - "NO_COLOR environment variable disables all ANSI codes"
        - "Color palette passes WCAG 2.1 AA (4.5:1 contrast)"
        - "VoiceOver can read all --plain output correctly"
        - "Status indicators use emoji + text (not color alone)"
      validation_method: "Manual testing with VoiceOver on macOS, colorblind simulation tools"
      revisit_trigger: "If Bubble Tea library has better accessibility primitives in future versions"

# Decision Backlog
# Decisions that need to be made but lack sufficient research
backlog:
  - id: "DB001"
    question: "HTTP client library selection (grab vs stdlib)"
    research_id: "R01"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Foundational decision for Go core"

  - id: "DB002"
    question: "Bubble Tea component library vs custom components"
    research_id: "R02"
    blocking_version: "1.1.0"
    urgency: "HIGH"
    notes: "Affects TUI development velocity"

  - id: "DB003"
    question: "Rate limiting algorithm selection"
    research_id: "R03"
    blocking_version: "1.2.0"
    urgency: "MEDIUM"
    notes: null

  - id: "DB004"
    question: "Screen reader testing approach"
    research_id: "R04"
    blocking_version: "1.1.0"
    urgency: "HIGH"
    notes: "RESOLVED - See decision D004"

  - id: "DB005"
    question: "State migration strategy (manual vs automated)"
    research_id: "R05"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Affects data safety guarantees"

  - id: "DB006"
    question: "GPG verification approach (pure Go vs subprocess)"
    research_id: "R06"
    blocking_version: "1.2.0"
    urgency: "LOW"
    notes: null

  - id: "DB007"
    question: "Package repository hosting (self-hosted vs GitHub only)"
    research_id: "R07"
    blocking_version: "1.3.0"
    urgency: "LOW"
    notes: null

  - id: "DB008"
    question: "REST API framework selection"
    research_id: "R08"
    blocking_version: "2.0.0"
    urgency: "LOW"
    notes: "Can defer, v2.0.0 is distant"

  - id: "DB009"
    question: "Plugin system architecture"
    research_id: "R09"
    blocking_version: "1.2.0"
    urgency: "MEDIUM"
    notes: null

  - id: "DB010"
    question: "CGO usage policy"
    research_id: "R10"
    blocking_version: "1.0.0"
    urgency: "HIGH"
    notes: "Affects entire build system"

# Expedited Decision Process
# For time-sensitive decisions that can't wait for full research
expedited_process:
  criteria_for_expedited:
    - "Blocking critical path for current sprint"
    - "Security vulnerability requiring immediate mitigation"
    - "External dependency EOL or critical bug"

  expedited_steps:
    - step: 1
      action: "Document decision need with justification"
      duration: "1 hour"

    - step: 2
      action: "Quick evaluation of top 2-3 options only"
      duration: "2-4 hours"

    - step: 3
      action: "Make provisional decision with explicit revisit date"
      duration: "Immediate"

    - step: 4
      action: "Create backlog item for full research validation"
      duration: "5 minutes"

  provisional_decision_template:
    id: "PD000"
    title: "Provisional: Decision Title"
    status: "PROVISIONAL"
    revisit_date: "YYYY-MM-DD"
    validation_research: "R00" # Research that will validate/revise this
    notes: "Made expedited because..."
